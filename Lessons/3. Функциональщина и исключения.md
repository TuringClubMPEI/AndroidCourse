# **Урок третий: Функции и всякие важные штуки**
## **Содержание**

1. **Функции** или 3 способа ошибиться в терминологии;

    1. **Способы передачи аргументов в функции**;

    2. **Множественные аргументы**;

    3. **Перегрузка**: делаем одно и то же по разному;

    4. **static и final**: что за звери;

    5. **Функции высокого порядка и лямбда-выражения**: "Я сделал тебе функцию внутри функции, чтобы ты мог использовать разные функции внутри функции"

        1. **Что такое функция высокого порядка?**

        2. **Как они реализуются в Java и в Kotlin**

2. **Исключения и их обработка**
    1. **Что такое исключения и почему они нужны**

    2. **Как их использовать**

    3. **try-catch-finally**

    4. **try-catch with resources**

3. **Что дальше и что пока не было затронуто**

4. **Домашнее задание**

5. **Литература и ссылки**


## 1. **Функции**

Подпрограмма - это именованый блок кода. Она может требовать для своего выполнения некоторые входные данные, называемые аргументами или не требовать таковых.

Подрограммы делятся на функции и процедуры. 

**Процедура** - подрограмма просто выполняющая некоторое действие и не возвращающая никакого результата. 

**Функция** - процедура, имеющая какое-либо возвращаемое значение. 

Так же существует такое понятие, как **метод** - функция или процедура, объявляемая в рамках класса и описывающая его поведение.

В рамках Java/Kotlin в основном используется понятие "метод", но на самом деле никакой строгости в реальности с этим нет и никто не будет гнобить тебя за то, что метод ты назовешь функцией, но знать в чем разница полезно.

**Пример объявления функции**

**Kotlin**
```kotlin                                                         
private fun foo(arg1: Type, arg2: AnotherType): ReturnType {
    //do smth...
    return objOfReturnType
}
```
**Java**
```java
private ReturnType foo(Type arg1, AnotherType arg2) {
    //do smth...
    return objOfReturnType;
}
```

Так же стоит отдельно упомянуть функции однострочники в Kotlin. Они объявляются следующим образом:

```kotlin      
private list = arrayListOf(1,2,3,4)

fun foo(position: Int) = list.get(position) //Возвращаемым типом этой функции будет Int

fun bar(): List<Int> = arrayListObj
```

Они нужны в случаях, когда нужно, например вызвать функцию объекта извне, но при этом не делать сам объект публичным или сделать какое-либо преобразование типов и т. д.

### **Способы передачи аргументов в функции**

В отличие от С/С++, в которых можно передать аргумент по значению или по ссылка, в Java/Kotlin мы никак не можем явно указать каким способом мы бы хотели передать аргумент в функцию. Он всегда будет передаваться по значению и никак иначе, однако, не стоит забывать, что в этих языках мы почти всегд оперируем не самими объектами, а ссылками на эти объекты.

Соответственно, в функциях на вход мы получаем копию ссылки на объект и если мы внутри вызванной функции изменим состояние переданного объекта, то оно изменится и снаружи функции, так как мы работаем с копией ссылки, но ссылается она на все тот же объект, на который ссылалась снаружи. 

Продемонстрируем на примере:

```kotlin      
fun foo() {
    var obj = mutableListOf(1, 2, 3)
    //Содержимое листа: 1, 2, 3
    bar(obj)
    //Содержимое листа: 1, 0, 3
}

fun bar(list: MutabeList<Int>) {
    list[1] = 0
}
```

### **Множественные аргументы**

Иногда могут возникнуть ситуации, когда нужно написать функцию, количество аргументов в которой изначально неизвестно. 

В таком случае можно попробовать использовать массив или List

```kotlin   
fun myPrint(args: Array<String>) {
    for (i in args.indices){
        println(args[i])
    }
}

```

Это первое, что приходит на ум, однако не самое оптимальное, ведь в случае, когда вам понадобится передать какие-то конкретные значения, перед передачей их в функцию придется формировать массив из этих значений:

```kotlin   
val s1 = "Turing"
val s2 = "was"
val s3 = "ga... genius!"

val array = arrayOf(s1, s2, s3)

myPrint(array)
```

Получается лишняя строчка и лишняя переменная, что не очень приятно, однако, как раз для таких случаев в Java и Kotlin есть такой инструмент, как varargs или множественные аргументы, использование которых выглядит следующим образом:

**Kotlin**
```kotlin   
fun myPrint(vararg args: String) {
    for (s in args) {
        println(s)
    }
}
```

**Java**
```java   
public void myPrint(String... args) {
    for (int i = 0; i < args.length; i++) {
        System.out.println(args[i]);
    }
}
```

Данный инструмент позволяет передать в функцию неопределенное количество аргументов одного и того же типа.

Пример использования:

```kotlin   
val s1 = "some text"
val s2 = "another text"

myPrint(s1, "text", "lalala", s2, "asdsa")
myPrint(s1, s2)
```

### **Перегрузка функций**

Допустим, мы хотим написать какие-то функции для математических операций, и нам нужно написать сложение:

```kotlin   
fun add(a: Int, b: Int) =  a + b
```

Но потом мы вспоминаем, что числа быватют не только целые и нужно предусмотреть и другие типы данных. Первое, что приходит в голову это что-то такое

```kotlin   
fun addInt(a: Int, b: Int) =  a + b

fun addFloat(a: Float, b: Float) = a + b

fun addDouble(a: Double, b: Double) = a + b
```

Но при таком подходе мы быстро запутаемся во всех этих именах, да и если нам вдруг захочется реализовать, например, сложение Double + Int + Float + Int то название станет уж совсем сложным.

На помощь приходит перегрузка функций - это механизм, позволяющий давать функциям одинаковые названия при условии, что у них разные аргументы.

Пример:

```kotlin   
fun add(a: Int, b: Int) =  a + b

fun add(a: Float, b: Float) = a + b

fun add(a: Double, b: Double) = a + b
```

### **static и final**

#### **static**

static - ключевое слово, позволющее сделать метод или поле класса глобальными, то есть, не зависящими от конкретного объекта класса. То есть методы или поля помеченные модификатором static вызываются от КЛАССА, а он от объекта. 

```java 
class A {

    public static int b = 0;

    public static void foo() {
        System.out.println("foo");
        bar()//ОШИБКА! Нельзя использовать не статические методы/поля в стаических функциях
    }

    public void bar() {
        System.out.println("bar");
        foo()
    }

}

class Main {

    public static void main(String[] args) {
        A.foo()
    }
}
```

Не смотря на то, что обычно в Java и Kotlin все примерно одинаково, в данном случае это немного не так, потому что ключевого слова static в Kotlin нет. В отличие от Java в случае, когда нам нужны глобальные функции, мы можем просто создать функцию без класса. 

Либо же, если очень хочется сделать именно глобальную функцию внутри какго-то класса, то на помощь приходит companion object: 

```kotlin
class A {
    private val b = 0

    fun bar() {
        println("bar")
        foo()
    }

    companion object {
        fun foo() {
            println("foo")
            bar()//ОШИБКА! bar() здесь недоступен!
        }
    }

}
```

В данном случае поведение этого класса будет полностью аналогично его клону на Java.

На самом деле object - очень мощное ключевое слово, с его помощью можно легко реализовать такой паттерн проектирования как "Одиночка" или Singletone

```kotlin
object SomeSigleClass {
    private val b = 0

    fun bar() {
        b++
        println("bar $b")
    }

}
```

Или создавать анонимные классы:

```kotlin
interface Moveable {
    fun go()
}

fun moveFiveTimes(moveable: Moveable) {
    repeat(5) {
        moveable.go()
    }
}

fun main(args: Array<String>) {
    val sasha = object : Moveable {
        override fun go() {
            println("Саша идет бухать, потому что Саша устал")
        }
    }
    moveFiveTimes(sasha)
    moveFiveTimes(object : Moveable {
        override fun go() {
            println("анонимный аноним идет взламывать пентагон")
        }
    })
}
```
 Анонимные классы можно создать и на Java

```java

class Main {

    interface Moveable {
        void go();
    }

    private static void moveFiveTimes(Moveable moveable) {
        for (int i = 0; i < 5; i++) {
            moveable.go();
        }
    }

    public static void main(String[] args) {
        Moveable sasha = () -> System.out.println("Саша идет бухать, потому что Саша устал");

        Moveable longSasha = new Moveable() {
            @Override
            public void go() {
                System.out.println("Саша идет бухать, потому что Саша устал");
            }
        };
        moveFiveTimes(longSasha);
        moveFiveTimes(sasha);
        moveFiveTimes(() -> System.out.println("короткий анонимный аноним идет взламывать пентагон"));
        moveFiveTimes(new Moveable() {
            @Override
            public void go() {
                System.out.println("длинный анонимный аноним идет взламывать пентагон");
            }
        });
    }
}
```

#### **final**

Ключевое слово final, в зависимости от контекста может означать разные вещи:

+ В рамках наследования оно означает конец ветки иерархии наследования, то есть, класс, от которого больше нельзя унаследоваться. Стоит упомянуть, что в Kotlin классы по умолчанию являются final. И если хочется унаследоваться от класса, то его нужно пометить как open. Аналогичная ситуация с применением final к методам

**Java**

```java
class A {
    protected int value = 1;

    protected void bar() {
        //do smth...
    }

    public final void foo(){
        value++;
    }
}

final class B extends A {
    protected int bValue = 2 + value;//компилятор уже недоумевает, тк protected бессмысленен в данном контексте

    @Ovveride
    public void foo() {//ОШИБКА: нельзя перегрузить final метод
        bValue++;
    }

    @Override
    void bar() {
        foo();//Будет вызван метод из класса родителя
    }
}

class C extends B {} //ОШИБКА: нельзя унаследоваться от final класса
```

**Kotlin**

```kotlin
open class A {
    protected var value = 1

    protected fun bar() {
        //do smth...
    }

    public final foo() {
        value++
    }
}

class B {
    protected var bValue = 1 + value

    override fun foo() {
        bValue++
    }

    override fun bar() {
        foo()
    }
}

class C : B() {}

```

+ Как модификатор поля final в Java означает неизменяемость данного поля, то есть является аналагом val в Koltin. То есть следующие строчки означают аналогичное поведение

```java
private final int constInt = 5;
```
```kotlin
private val constInt = 5
```

### **Функции высокого порядка и лямбда выражения** 

#### **Что такое функции высокого порядка?**

Функция высокого порядка - функция, принимающая в качестве аргумента другую функцию. Звучит странно? Согласен. Но зачем же это нужно? На самом деле область применения просто огромна. Самое частое - callback.

#### **Как они реализуются в Java и Kotlin**

То, как реализуются функции высокого поряка в этих двух язках - одно из самых заметных их отличий, потому что, строго говоря, в Java нет функций высокого порядка. Есть функции принимающие в качестве аргумента функциональный интерфейс. Функциональный интерфейс - это интерфейс в котором объявлен один асбтрактный метод.

```Java
class Main {

    interface Moveable {
        void go();
    }

    private static void moveFiveTimes(Moveable moveable) {
        for (int i = 0; i < 5; i++) {
            moveable.go();
        }
    }

    public static void main(String[] args) {
        Moveable sasha = () -> System.out.println("Саша идет бухать, потому что Саша устал");

        Moveable longSasha = new Moveable() {
            @Override
            public void go() {
                System.out.println("Саша идет бухать, потому что Саша устал");
            }
        };
        moveFiveTimes(longSasha);
        moveFiveTimes(sasha);
        moveFiveTimes(() -> System.out.println("короткий анонимный аноним идет взламывать пентагон"));
        moveFiveTimes(new Moveable() {
            @Override
            public void go() {
                System.out.println("длинный анонимный аноним идет взламывать пентагон");
            }
        });
    }
}
```
Выглядит знакомо не правда ли? По сути в тот раз мы как раз таки и сделали функцию высокого порядка на Java. То есть, реализация функций высокого порядка на Java заключается в передаче в функцию анонимной реализации интерфейса в качестве аргумента.

На деле, анонимные классы можно создавать не только из интерфейсов, но еще и из абстрактных классов. О них мы еще не говорили, но обязательно когда-нибудь поговорим.

Так а как же реализуются функции высокого порядка на Kotlin? В этом языке существует поддержка функционального программирования, что значит, что функции могут существовать вне классов, а так же, это означает что к нам в распоряжение попадают такие прекрасные инструменты, как функциональные переменные.

```kotlin
fun main(args: Array<String>) {
    val sasha: () -> Unit = { 
        println("Саша идет бухать, потому что Саша устал") 
    }

    repeatFiveTimes(sasha)
    repeatFiveTimes {
        println("ееее красивые лямбды")
    }

    repeatFiveTimes { someWord -> 
        println(someWord)
    }

}

fun repeatFiveTimes(callback: () -> Unit) = repeat(5) {
    callback()
}

fun repeatFiveTimes(callback: (String) -> Unit) = repeat(5) {
    callback("some text")
}
```

На мой взгляд, выглядит гораздо приятней чем на Java.

## **2. Исключения и их обработка**

### **Что такое исключения и почему они нужны**

Исключения - это, если успрощать, ошибки, возникающие в программе и экстренно завершающие её, если они не были должным образом обработаны. Казалось бы, а зачем нам что-то, что вообще убивает программу и завершает её работу? Ошибка и ошибка че бубнить-то?

На деле, исключения созданы, чтобы сообщить нам о возможном неопределенном поведении программы.

Почему же просто не использовать какой-то другой инструмент, который не убивал бы программу? Например, если та или иная операция завершилась с ошибкой, то функция возвращает -1 или False какой-нибудь. 

А все потому, что любые такие способы не обязывают программиста разбираться с такими ситуациями и не очень внимательный разработчик легко может упустить такой моментик.

В Java/Kotlin все исключения имеют некоторую иерархию наследования представленную на картинке:

![alt text](images/exceptions_hierarchy.jpeg)

Здесь вы можете заметить пару странностей:

Во-первых, почему-то все они наследуются от какого-то Object. На деле все классы в Java неявно наследуются от Object. В Kotlin все классы неявно наследуются от Any, хотя на деле это просто другое название для того же Object

Во-вторых, они разделены на checked и unchecked. Это исключительно (ха-ха) фича Java. Придержали пока это в голове, чуть дальше разберемся.

## **Как их использовать?**

Все очень просто: в случае, если вы хотите указать в своем методе, что он может генерировать исключение, то мы используем ключевое слово throws.

Но есть один нюанс: в Java, в случае если мы выкидываем checked исключение в своей функции, то мы должны указать это в сигнатуре функции, чтобы обязать любого, кто работает с этой функцией обернуть её в try-catch

```java
class Main {

    public static void main(String[] args) {
        someIoFunc() //ОШИБКА! нужно обернуть в try-catch
        divide(1.4, 0.0) //выкинет исключение и программа завершится
    }

    private static double divide(double a, double b) throws  {
        if(b == 0.0) {
            throw new ArithemicException("divide by zero!");
        }
        return a/b;
    }

    private static void someIoFunc() throws IOException {
        //some io code
        if (someCondition) {
            throw new IOException("some io error notify text");
        }
        //some next io code
    }

}
```
На kotlin синтаксис выбрасывания исключений почти такой же, но при этом понятия checked/unchecked исключений там нет, соответственно в сигнатуре функции мы не обязаны ничего указывать, даже если выкидываем checked исключение.

```kotlin
fun divide(a: Double, b: Double) {
    if (b == 0.0) {
        throw ArithemicException("divide by zero!")
    }
    return a/b
}
```
 ## **try-catch-finally**
Для обработки исключений в Kotlin и Java существует блок try-catch. Блок try содержит код, который потенциально бросает исключение, а блок catch используется для того, чтоб это исключение отловить

В этом примере возникнет исключение из-за попытки деления на ноль, но программа продолжит выполнять инструкции после блока try-catch
```kotlin
fun main() {
    try{
        val x = 0
        val n = 0 / x
        println(n)
    }
    catch(e: Exception){
        println(e.message)
    }
    println("Other program blocks")
}
```
Если необходимо выполнить действия вне зависимости от результата в блоке try-catch, можно добавить блок finally:
```kotlin
fun main() {
    try{
        val x = 0
        val n = 0 / x
        println(n)
    }
    catch(e: Exception){
        println(e.message)
        return // даже при наличии оператора return блок finally будет выполнен
    }
    finally{
        println("Program has been finished") //этот код выполнится в любом случае
    }
}
```
Обработка нескольких типов исключений 

Код может генерировать множество типов исключений. Можно добавлять несколько блоков catch для создания индивидуальной обработки для каждого исключения

В начале будет обработано исключение более частного типа, поэтому выполнится блок с ArithmeticException.
Если же произойдет исключение, для которого нет частного обработчика, выполнится блок с общим типом Exception
 ``` kotlin
 fun main() {
    try{
        val x = 0
        val n = 0 / x
        println(n)
    }
    catch(e: ArithmeticException){
        println("Division by zero")
    }
    catch (e: Exception){
        println("Exception")
        println(e.message)
    }
}
```
Также в Kotlin обработчик исключений можно использовать как выражение:

```kotlin
val value = try {Integer.parseInt(“not a number”)}
	catch(e: NumberFormanException) { -1 } // при возникновении исключения переменной value будет присвоено значение -1, иначе -  результат преобразования строки в число
```
То же самое можно проделать с throw. Допустим, нам важно, чтобы какое-то значение было не null и мы хотим сообщить об этом:

```kotlin
val s = someObject
	?: throw IllegalArgumentException(“Обязательный параметр!!!”)
```
## **try-catch with resources**

Иногда программа захватывает некоторые внешние ресурсы, например, файлы. Однако, после работы необходимо освободить этот ресурс - сообщить операционной системе, что он больше не используется программой. Иначе он так и будет недоступен для других процессов.
Например, попробуем записать что-то в файл
``` java
public static void main(String[] args) throws IOException {
        FileOutputStream output = new FileOutputStream("path"); //создали объект потока записи в файл
        try {
            output.write(1);//запишем в файл что-нибудь
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            output.close(); // освободили ресурсы вне зависимости от результата в блоке try
        }
    }
```
Но разработчик может забыть освободить ресурсы и получить проблемы с памятью. Для решения этой проблемы в java придумали оператор try-catch with resources

``` java
 public static void main(String[] args) {
        try (FileOutputStream output = new FileOutputStream("path")) {
            output.write(1);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```
Теперь нам не нужно прописывать явное закрытие ресурса, так как это произойдет автоматически. Также исчезла необходимость указывать в сигнатуре метода возможность возникновения исключения, так как теперь вся обработка происходит в блоке try-catch

В Kotlin нет оператора try-with-resources. Вместо этого в языке есть функция-расширение use. Однако, в отличие от try-with-resources, она действует только на один закрываемый ресурс, поэтому при работе с несколькими закрываемыми объектами придется создавать вложенность.

``` kotlin
fun main() {
    val outputStream = FileOutputStream("Path")
    outputStream.use {
        outputStream.write(1)
    }
}
```

## **3. Что дальше и что пока не было затронуто**

Начиная со следующего занятия мы начнем рассматривать программирование непосредственно под Android. 

Однако, это не означает, что мы успели рассмотреть все аспекты Java/Kotlin. Мы не успели ознакомится с Generics, с функциями расширения, с абстрактными классами и многим другим. Но все эти аспекты языков будут изучены далее вместе с изучением платформы Android.

## **4. Домашнее задание**

!!!ВАЖНО!!!

**К следующему уроку тем, кто еще этого не сделал, нужно установить себе Android Studio.**

Реализовать класс простейшего калькулятора, в котором будут определены ТОЛЬКО следующие public методы:

```kotlin
fun setOperation(
    operation: (a: Double, b: Double) -> Double
)

fun execute(
    a: Double, 
    b: Double
): Double
```

Интерфейс данного класса описан в базовом коде для д/з.

Необходимо реализовать в программе следующие операции:

+ сложение
+ умножение
+ вычитание
+ деление

В программе должна быть предусмотрена обработка ошибок с помощью исключений. Должны быть предусмотрены как ошибки арифметики (например деление на ноль), так и ошибки ввода.

Так же необходимо написать консольное приложение для демонстрации работы данного класса.

**После клонирования базового кода для д/з открываем папку hw3 КАК ПРОЕКТ. Иначе оно не будет работать.**

**Базовый вариант:**

Входными данными являются два числа и выбранная операция, вводимые по-отдельности.

**Усложненный вариант:**

Входными данными является строка вида "a operation b", где a и b - числа с которыми производится операция, operation - символ операции, которую нужно произвести (например + или -)

**Вариант для мазохистов:**

Тем кто сделает - с меня небольшой презент на шашлыках

Входными данными - это строка, являющаяся сложным выражением, например, "(15+17)/2+78-16"

Необходимо создать некоторый класс, который будет содержать в себе объект простейшего калькулятора и будет обрабатывать подобную строку и выдавать результат.

## **5. Литература и ссылки**

1. [Руководство по Kotlin. Глава 3. Функциональное программирование][1]
2. [Руководство по Kotlin. Искючения.][2]


[1]: https://metanit.com/kotlin/tutorial/3.1.php
[2]: https://metanit.com/kotlin/tutorial/5.2.php